# Тема сложная, лучше читать с видео
# Алгоритм Бойера-Мура-Хорспула оптимизиует поиск образа в строке

# Состоит из 2 этапов:


# 1. Формирование таблицы смешений
# начинается с конца с предпоследнего символа, для повторяющийся символов указываем смещение найденное ранее,
# для последнего символа если ранее небыло найдено, то длинна строки,
# иначе смещение того же символа, который мы нашли ранее,
# после последнего символа указываем звёздочку (смещение последнего символа), потом убираем дублирование смещения


# 2. поиск образа в стоке
# Начинаем поиск с последнего символа
# Если несовпадение, берем символ строки который не совпал и обращаемся к нашей таблице смещения
# (если его нет, смотрим на звездочку)
# Повторяем снова
# Если символы равны, то переносим указатель в строке влево
# Есть правило ЕСЛИ НЕСОВПАДЕНИЕ ПРОИСХОДИТ НЕ ДЛЯ ПОСЛЕДНЕГО СИМВОЛА, ТО БЕРЕМ СИМВОЛ ДЛЯ ОБРАЗА ИЗ ПОДСТРОКИ,
# А ДЛЯ ВСЕХ ОСТАЛЬНЫХ ИЗ СТРОКИ

# Наш образ
t = "данные"

# 1. Формирование таблицы смешений

# Словарь смещений
S = set()
# Число символов в образе
M = len(t)
# Словарь смещений
d = {}

# Итерации с предпоследнего символа
for i in range(M-2, -1, -1):
    # Если символ еще не добавлен в таблицу
    if t[i] not in S:
        # Добавляем в Словарь смещений вложенный словарь символ(ключ), а значение это смещение(от конца образа)
        d[t[i]] = M - i - 1
        # Чтобы повторяющие символы мы не добавляли в Уникальные символы в образе
        S.add(t[i])

# Отдельно формируем последний символ
# Если символа нет в Словаре смещений, то указываем смещение равное Числу символов в образе
if t[M-1] not in S:
    d[t[M-1]] = M

# Смещения для прочих символов
d['*'] = M

print(d)


# 2. поиск образа в стоке

# Строка в котором ищем подстроку
a = "метеоданные"
# Длинна массива
N = len(a)

# Если длинна строки больше или равна длиннее образа(в этом случае запускаем алгоритм поиска), иначе образ не найден
if N >= M:
    # Счетчик проверяемого символа в строке(указывает на символ, с которым мы работаем в строке)
    i = M-1

    while (i < N):
        k = 0
        j = 0
        flBreak = False

        # j указывает на текущий символ подстроки, с которым мы работаем
        for j in range(M-1, -1, -1):
            # i - k счетчик для охвата предыдущих символов в строке
            # Если символы не совпали

            if a[i-k] != t[j]:
                # Символ является последним

                if j == M-1:
                    # Определяем смещение по символу строки
                    # (если есть в Словаре смещений символ, мы его берем как текущий символ, иначе берем значение '*')
                    off = d[a[i]] if d.get(a[i], False) else d["*"]
                # Иначе определяем смещение определяем по символу образа
                else:
                    off = d[t[j]]
                # Смещение счётчика строки
                i += off
                # Если несовпадение символа, то flBreak = True
                flBreak = True
                break

            # Смещение для сравниваемого символа в строке
            k += 1

        # Если дошли до конца образа, значит все его символы совпали
        if not flBreak:
            print(f'Образ найден, начало по индексу {i-k+1}')
            break
    else:
        print('Образ не найден')
else:
    print("Образ не найден")